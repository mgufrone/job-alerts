package template

import (
	"fmt"
	"github.com/dave/jennifer/jen"
	"go/types"
	"golang.org/x/sync/errgroup"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"golang.org/x/tools/go/packages"
	"strings"
)

type pkgResolver string

const (
	helperPkg pkgResolver = "%root%/pkg/helpers"
	usrPkg    pkgResolver = "%root%/internal/domain/user"
	jsonPkg               = "github.com/buger/jsonparser"
	tryPkg                = "github.com/mgufrone/go-utils/try"
	uuidPkg               = "github.com/google/uuid"
)

func (p pkgResolver) String(root string) string {
	return strings.ReplaceAll(string(p), "%root%", root)
}

type Entity struct {
	Root    string
	PkgRoot string
	Pkg     *packages.Package
	Str     *types.Struct
}

func (e *Entity) Package() string {
	pkg := strings.Split(e.Pkg.ID, "/")
	return pkg[len(pkg)-1]
}
func (e *Entity) EntityName() string {
	return cases.Title(language.English).String(e.Package())
}
func (e *Entity) PackageLocation() string {
	return e.Root + "/" + strings.ReplaceAll(e.Pkg.ID, e.PkgRoot, "")
}

func (e *Entity) GenerateBlockCodes() error {
	var wg errgroup.Group
	type proc func() error
	processes := []proc{
		e.generateConstructor,
		e.generateMarshaler,
	}
	for _, p := range processes {
		wg.Go(p)
	}
	if err := wg.Wait(); err != nil {
		fmt.Println("error", err)
		return err
	}
	return nil
}
func (e *Entity) basicElementMarshaler(v1 *types.Basic, field *types.Var, fieldName string) jen.Code {
	//var res []string
	//_, err := jsonparser.ArrayEach(data, func(value []byte, dataType jsonparser.ValueType, offset int, err error) {
	//	res = append(res, string(value))
	//}, "status")
	codes := []jen.Code{
		jen.Id("res").Op("=").Append(jen.Id("res"), jen.Id(v1.Name()).Call(jen.Id("value"))),
	}
	switch v1.Kind() {
	case types.Int, types.Int32, types.Int64:
		codes = []jen.Code{
			jen.Id("v").Op(",").Id("_").Op(":=").Qual("strconv", "Atoi").Call(jen.String().Call(jen.Id("value"))),
			jen.Id("res").Op("=").Append(jen.Id("res"), jen.Id(v1.Name()).Call(jen.Id("v"))),
		}
	case types.Float64:
		codes = []jen.Code{
			jen.Id("v").Op(",").Id("_").Op(":=").Qual("strconv", "ParseFloat").Call(jen.String().Call(jen.Id("value")), jen.Lit(64)),
			jen.Id("res").Op("=").Append(jen.Id("res"), jen.Id("v")),
		}
	case types.Float32:
		codes = []jen.Code{
			jen.Id("v").Op(",").Id("_").Op(":=").Qual("strconv", "ParseFloat").Call(jen.String().Call(jen.Id("value")), jen.Lit(64)),
			jen.Id("res").Op("=").Append(jen.Id("res"), jen.Id(v1.Name()).Call(jen.Id("v"))),
		}
	case types.Byte:
		// force return for bytes
		return jen.Func().Call().Error().Block(
			jen.Id("res").Op(",").Id("_").Op(",").Id("_").Op(",").Id("err").Op(":=").Qual(jsonPkg, "Get").
				Call(jen.Id("data"), jen.Id(fmt.Sprintf(`"%s"`, fieldName))),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Id("err")),
			),
			jen.Return(jen.Id("e").Dot("Set"+methodName(field.Name())).Call(jen.Id("res"))),
		)
	}

	return jen.Func().Call().Error().Block(
		jen.Var().Id("res").Op("[]").Id(v1.Name()),
		jen.Id("_").Op(",").Id("err").Op(":=").Qual(jsonPkg, "ArrayEach").
			Call(jen.Id("data"), jen.Func().Call(
				jen.Id("value").Op("[]").Byte(),
				jen.Id("dataType").Qual(jsonPkg, "ValueType"),
				jen.Id("offset").Int(),
				jen.Id("err").Error(),
			).Block(codes...), jen.Id(fmt.Sprintf(`"%s"`, fieldName))),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Id("err")),
		),
		jen.Return(jen.Id("e").Dot("Set"+methodName(field.Name())).Call(jen.Id("res"))),
	)
}
func (e *Entity) generateMarshaler() error {
	f := jen.NewFile(e.Package())
	f.PackageComment(fmt.Sprintf("Code generated by %s/cmd/generate-domain, DO NOT EDIT.", e.PkgRoot))
	var (
		unmarshalers []jen.Code
		marshals     []jen.Code
	)
	for i := 0; i < e.Str.NumFields(); i++ {
		field := e.Str.Field(i)
		var (
			msh       jen.Code
			marshaler string
			enc       jen.Code
		)
		fieldName := field.Name()
		marshaler = methodName(fieldName)
		switch v := field.Type().(type) {
		case *types.Basic:
			decoderPkg := jsonPkg
			typeName := "string"
			switch v.Info() {
			case types.IsInteger:
				typeName = "int"
			case types.IsFloat:
				typeName = "float"
			case types.IsBoolean:
				typeName = "boolean"
			}
			decoderMethod := "Get" + methodName(typeName)
			msh = marshalFunc(decoderPkg, decoderMethod, field)
		case *types.Named:
			obj := v.Obj()
			decoderPkg := helperPkg.String(e.PkgRoot)
			var decoderMethod string
			if obj.Pkg().Path() == e.Pkg.ID {
				decoderMethod = "Get" + methodName(obj.Type().Underlying().String())
				msh = jen.Func().Call().Error().Block(
					jen.Id("val").Op(",").Id("err").
						Op(":=").Qual(jsonPkg, decoderMethod).
						Call(jen.Id("data"), jen.Id(fmt.Sprintf(`"%s"`, fieldName))),
					jen.If(jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Id("err")),
					),
					jen.Return(jen.Id("e").Dot("Set"+methodName(field.Name())).Call(jen.Id(obj.Name()).Call(jen.Id("val")))),
				)
				enc = jen.Id(fmt.Sprintf(`"%s"`, fieldName)).Op(":").Id(obj.Type().Underlying().String()).Call(jen.Id("e").Dot(marshaler).Call()).Op(",")
				break
			}
			if obj.Name() == "Time" {
				decoderMethod = "GetTime"
				marshaler = fmt.Sprintf("%s().UnixMilli", marshaler)
			}
			if obj.Name() == "UUID" {
				decoderMethod = "GetUUID"
			}
			msh = marshalFunc(decoderPkg, decoderMethod, field)
		case *types.Pointer:
			obj := v.Elem()
			pkgs := strings.Split(obj.String(), "/")
			types1 := strings.Split(pkgs[len(pkgs)-1], ".")
			if v.Elem().String() == "time.Time" {
				msh = unmarshalNilableTime(field, e)
				enc = marshalNilableTime(helperPkg.String(e.PkgRoot), marshaler, field)
			}
			if strings.Index(obj.String(), e.PkgRoot) >= 0 {
				marshaler = methodName(fieldName) + "()." + "ID"
				originalFieldName := fieldName
				fieldName = fieldName + "ID"
				// case when the type is user
				mshBlocks := []jen.Code{
					jen.Var().Id("ref").Qual(strings.Join(append(pkgs[:len(pkgs)-1], types1[0]), "/"), types1[1]),
					jen.Id("val").Op(",").Id("err").
						Op(":=").Qual(helperPkg.String(e.PkgRoot), "GetUUID").
						Call(jen.Id("data"), jen.Id(fmt.Sprintf(`"%s"`, fieldName))),
					jen.If(jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Id("err")),
					),
					jen.If(jen.Id("val").Op("==").Qual(uuidPkg, "Nil")).Block(
						jen.Return(jen.Nil()),
					),
				}
				if types1[0] == "user" && types1[1] == "Entity" {
					userPackage := usrPkg.String(e.PkgRoot)
					roleKey := fmt.Sprintf("%s_roles", originalFieldName)
					if originalFieldName == "lastModifiedBy" {
						roleKey = "lastModifiedBy"
					}
					enc1 := jen.Id(fmt.Sprintf(`"%s"`, roleKey)).Op(":").Func().Call().Int().Block(
						jen.Return(jen.Id("int").Call(jen.Id("e").Dot(methodName(originalFieldName)).Call().Dot("Roles").Call())),
					).Call().Op(",")
					enc = jen.Id(fmt.Sprintf(`"%s"`, fieldName)).Op(":").Func().Call().Qual(uuidPkg, "UUID").Block(
						jen.If(jen.Id("e").Dot(methodName(originalFieldName)).Call().Op("==").Nil()).Block(
							jen.Return(jen.Qual(uuidPkg, "Nil")),
						),
						jen.Return(jen.Id("e").Dot(methodName(originalFieldName)).Call().Dot("ID").Call()),
					).Call().Op(",")
					marshals = append(marshals, enc1)
					mshBlocks = append(mshBlocks,
						jen.Id("roles").Op(",").Id("err").
							Op(":=").Qual("github.com/buger/jsonparser", "GetInt").
							Call(jen.Id("data"), jen.Id(fmt.Sprintf(`"%s"`, roleKey))),
						jen.If(jen.Id("err").Op("!=").Nil()).Block(
							jen.Return(jen.Id("err")),
						),
						jen.Id("_").Op("=").Id("ref").Dot("SetRoles").Call(jen.Qual(userPackage, "Role").Call(jen.Id("roles"))),
					)
				}
				msh = jen.Func().Call().Error().Block(
					append(mshBlocks,
						jen.Id("_").Op("=").Id("ref").Dot("SetID").Call(jen.Id("val")),
						jen.Return(jen.Id("e").Dot("Set"+methodName(field.Name())).Call(jen.Op("&").Id("ref"))),
					)...,
				)
			}
		case *types.Slice:
			switch v1 := v.Elem().(type) {
			case *types.Basic:
				msh = e.basicElementMarshaler(v1, field, fieldName)
			case *types.Pointer:

			}
		case *types.Array:
			switch v1 := v.Elem().(type) {
			case *types.Basic:
				msh = e.basicElementMarshaler(v1, field, fieldName)
			}

		default:
			fmt.Println("cannot parse", v.String())
		}
		if enc == nil {
			enc = jen.Id(fmt.Sprintf(`"%s"`, fieldName)).Op(":").Id("e").Dot(marshaler).Call().Op(",")
		}
		marshals = append(marshals, enc)
		unmarshalers = append(unmarshalers,
			msh,
		)
	}
	f.Func().
		Params(jen.Id("e").Op("*").Id("Entity")).
		Id("UnmarshalJSON").Params(jen.Id("data").Op("[]").Byte()).
		Parens(jen.Error()).
		Block(jen.Return(
			jen.Qual(tryPkg, "RunOrError").Call(
				unmarshalers...,
			),
		))
	marshalers := []jen.Code{
		jen.Id("res").Op(":=").Map(jen.String()).Interface().Block(
			marshals...,
		),
		jen.Return(jen.Qual("encoding/json", "Marshal").Call(jen.Id("res"))),
	}
	f.Func().
		Params(jen.Id("e").Op("*").Id("Entity")).
		Id("MarshalJSON").Params().
		Parens(jen.List(jen.Index().Byte(), jen.Error())).
		Block(marshalers...)
	return f.Save("entity_marshaler.gen.go")
}

func (e *Entity) generateConstructor() error {
	f := jen.NewFile(e.Package())
	f.PackageComment(fmt.Sprintf("Code generated by %s/cmd/generate-domain, DO NOT EDIT.", e.PkgRoot))
	var (
		params []jen.Code
		blocks []jen.Code
		tries  []jen.Code
	)
	for i := 0; i < e.Str.NumFields(); i++ {
		field := e.Str.Field(i)
		var param jen.Code
		switch v := field.Type().(type) {
		case *types.Basic:
			param =
				jen.Id(field.Name()).Id(v.String())

		case *types.Named:
			obj := v.Obj()
			param = jen.Id(field.Name()).Id(obj.Name())
			if obj.Pkg().Path() != e.Pkg.ID {
				param =
					jen.Id(field.Name()).Qual(
						obj.Pkg().Path(),
						obj.Name(),
					)
			}
		case *types.Pointer:
			obj := v.Elem()
			pkgs := strings.Split(obj.String(), "/")
			types1 := strings.Split(pkgs[len(pkgs)-1], ".")

			param =
				jen.Id(field.Name()).Op("*").Qual(
					strings.Join(append(pkgs[0:len(pkgs)-1], types1[0]), "/"),
					types1[1],
				)
		case *types.Slice:
			switch v1 := v.Elem().(type) {
			case *types.Basic:
				param =
					jen.Id(field.Name()).Op("[]").Id(v1.String())
			}
		case *types.Array:
			switch v1 := v.Elem().(type) {
			case *types.Basic:
				param =
					jen.Id(field.Name()).Op("[]").Id(v1.String())
			}

		default:
			fmt.Println("cannot parse", v.String())
		}
		try := jen.Func().Call().Error().Block(
			jen.Return(jen.Id("res").Dot("Set" + methodName(field.Name())).Call(jen.Id(field.Name()))),
		)
		params = append(params, param)
		tries = append(tries,
			try,
		)
	}
	blocks = []jen.Code{
		jen.Var().Id("res").Id("Entity"),
		jen.Id("err").Op("=").Qual(tryPkg, "RunOrError").Call(
			tries...,
		),
		jen.If(jen.Id("err").Op("==").Nil()).Block(
			jen.Id("ent").Op("=").Op("&").Id("res"),
		),
		jen.Return(),
	}
	f.Func().
		Id("New").
		Params(params...).
		Params(jen.Id("ent").Op("*").Id("Entity"), jen.Id("err").Error()).
		Block(blocks...)
	return f.Save("entity_constructor.gen.go")
}

func methodName(str string) string {
	if str == "id" {
		return "ID"
	}
	if str == "url" {
		return "URL"
	}
	return strings.Title(str)
}
func marshalFunc(decoderPkg, decoderMethod string, field *types.Var) jen.Code {
	val := jen.Id("val")
	if decoderMethod == "GetInt" && field.Type().String() != "int64" {
		val = jen.Id(field.Type().String()).Call(val)
	}
	return jen.Func().Call().Error().Block(
		jen.Id("val").Op(",").Id("err").Op(":=").Qual(decoderPkg, decoderMethod).Call(jen.Id("data"), jen.Id(fmt.Sprintf(`"%s"`, field.Name()))),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Id("err")),
		),
		jen.Return(jen.Id("e").Dot("Set"+methodName(field.Name())).Call(val)),
	)
}
func unmarshalNilableTime(field *types.Var, t *Entity) jen.Code {
	return jen.Func().Call().Error().Block(
		jen.Id("val").Op(",").Id("err").Op(":=").Qual(helperPkg.String(t.PkgRoot), "GetTime").Call(jen.Id("data"), jen.Id(fmt.Sprintf(`"%s"`, field.Name()))),
		jen.If(jen.Id("val").Dot("IsZero").Call().Op("||").Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil()),
		),
		jen.Return(jen.Id("e").Dot("Set"+methodName(field.Name())).Call(jen.Op("&").Id("val"))),
	)
}
func marshalNilableTime(decoderPkg, decoderMethod string, field *types.Var) jen.Code {
	call := jen.Id("e").Dot(decoderMethod).Call()
	return jen.Id(fmt.Sprintf(`"%s"`, field.Name())).Op(":").Func().Call().Interface().Block(
		jen.If(call.Op("==").Nil()).Block(
			jen.Return(jen.Nil()),
		),
		jen.Return(jen.Id("e").Dot(decoderMethod).Call().Dot("UnixMilli").Call()),
	).Call().Op(",")
}
